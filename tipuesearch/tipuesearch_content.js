var tipuesearch = {"pages":[{"title":" ForSudoku ","text":"ForSudoku A Fortran sudoku generator and solver Requirements and dependencies Running the program 1) Manual entry of a grid 2) Read a grid from a text file 6) Generation of a completed Sudoku grid 7) Solve a puzzle grid. 8) Create a minimal puzzle 9) Create a minimal puzzle with n given digits 10) Create a puzzle grid (not guaranteed to have a unique solution) Development License Bibliography A Fortran sudoku generator and solver Requirements and dependencies You need: a modern Fortran compiler, for example GFortran or the Intel ifort/ifx\n  compilers. See the Fortran-lang.org compilers\n  page for other compilers. The Fortran Package Manager fpm . Running the program The recommended approach is to use fpm : $ fpm run\nsudoku.f90 done .\nlibForSudoku.a done .\nmain.f90 done .\nForSudoku done . [ 100 % ] Project compiled successfully. If you want to generate a sudoku with less than 33 givens, it is better to use the\noptimization flags of your compiler, for example with GFortran: $ fpm run --flag \"-Ofast -static-libgfortran\" When using GFortran, you can also add the compiler flag -Wno-array-temporaries to avoid the corresponding warnings. With Intel compilers: $ fpm run --compiler ifx --flag \"-check:noarg_temp_created\" The Makefile equally provides you with the executable with no difference down the\nroad. The program’s main interface provides access to all principal functions: ******************************** MENU ************************************** 1 ) Manual input ( lines of comma separated 1 - 9 , or 0 ( empty cell )) . 2 ) Read a grid from a text file ( for permitted patterns, see the doc ) . 3 ) Save the current grid in a text file. 4 ) Check the validity of the current grid. 5 ) Display the current grid. 6 ) Create a random completed Sudoku grid. 7 ) Solve the puzzle grid currently stored in memory. 8 ) Create a minimal puzzle, starting from the grid in memory. 9 ) Create a minimal puzzle with exactly n given digits. 10 ) Create a puzzle grid ( without guaranty for a unique solution ) . 0 ) Quit. 1) Manual entry of a grid In this mode, sequentially enter cells one by one, starting from the left, as a comma separated line.  Use any number 1 to 9 for known cells.  For empty cells, enter either 0 (recommended), or a blank space instead.  After typing the last cell in the\ncurrent line (which is not followed by a comma), submit the line by Enter : Enter line 1 : 1 ,2,3,4,5,6,7,8,9 Upon completion of the input, the program quickly checks if the grid is valid\nand displays it in such a format: 5 3 0 | 0 7 0 | 0 0 0 6 0 0 | 1 9 5 | 0 0 0 0 9 8 | 0 0 0 | 0 6 0 ------+-------+------ 8 0 0 | 0 6 0 | 0 0 3 4 0 0 | 8 0 3 | 0 0 1 7 0 0 | 0 2 0 | 0 0 6 ------+-------+------ 0 6 0 | 0 0 0 | 2 8 0 0 0 0 | 4 1 9 | 0 0 5 0 0 0 | 0 8 0 | 0 7 9 If the input is considered a valid one, you can then use that grid with the other options. 2) Read a grid from a text file If the file to read is not in the root directory of the project, type the relative path, for example test/a_puzzle_with_17_givens.txt . The folder test/ also contains a few grids for testing. And you can create your own grid starting from test/template.txt file (a grid filled with zeroes). The present form of the program only reliably supports the input of a grid in the format depicted above. 6) Generation of a completed Sudoku grid The program generates a random completed Sudoku by brute force: in each cycle a digit is added and checked for validity. If the grid became invalid, the grid generation is started all over again, until a valid grid is obtained. But the process is very quick. The new grid replaces the previous grid stored in memory. 7) Solve a puzzle grid. The puzzle in memory is solved by brute force. But the process is very quick. It is also possible to pass the filename of the puzzle to solve on the command line. With fpm you can type for example from the root directory of the project: $ fpm run -- test/a_puzzle_with_17_givens.txt If you have used the makefile, you can type: $ ./executable test/a_puzzle_with_17_givens.txt 8) Create a minimal puzzle If a completed valid grid is not in memory, we will start from a new one. As the algorithm uses random numbers to remove digits in the grid, following validity rules, the final number of given digits is a priori unknown. The obtained puzzle will be typically half-empty (and quick in that case), or more empty if you are lucky. 9) Create a minimal puzzle with n given digits You can ask the program any number of given digits in the [17, 81] range, but the computation will become longer below 33 as the algorithm is based on brute force: it launches the previous option until we obtain a puzzle with exactly n given digits. 10) Create a puzzle grid (not guaranteed to have a unique solution) You can obtain puzzles with still less given digits with this method, but without guaranty that the solution is unique. Development You can use those GFortran flags: $ fpm build --verbose --flag \"-std=f2018 -pedantic -Wall -Wextra\" In app/main.f90 , you should pass 0 as a seed at the top of the file: call initialize_random_number_generator ( 0 ) You will then obtain the same pseudo-random sequence at each run, which is more comfortable for debugging, testing or optimizing the CPU time. License This project is licensed under the GNU General Public License version 3 or\nlater . The logo files are under CC-BY-SA 4.0. Bibliography https://en.wikipedia.org/wiki/Sudoku https://en.wikipedia.org/wiki/Glossary_of_Sudoku https://en.wikipedia.org/wiki/Mathematics_of_Sudoku Jean-Paul Delahaye, “The Science behind Sudoku” , Scientific American, Vol. 294, No. 6, pp. 80-87, June 2006, DOI:10.1038/scientificamerican0606-80. This is the English translation of: Jean-Paul Delahaye, “Le tsunami du Sudoku” , Pour la Science, n°338, p. 144-149, décembre 2005. Michael Metcalf. A Sudoku program in Fortran 95. SIGPLAN Fortran Forum 25,\n1 (April 2006), 4–7. https://doi.org/10.1145/1124708.1124709 Other Fortran sudoku projects on GitHub. Developer Info vmagnin, nbehrnd","tags":"home","loc":"index.html"},{"title":"is_full – ForSudoku","text":"public pure function is_full(grid) Returns true if the grid is full. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(9, 9) :: grid Sudoky grid. Return Value logical","tags":"","loc":"proc/is_full.html"},{"title":"valid_colum_or_row – ForSudoku","text":"public pure function valid_colum_or_row(vector) Validation routines Validation of either a row or a column. Returns true if each digit in the 1D array appears only once Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(1:9) :: vector A row or a column Return Value logical Called by proc~~valid_colum_or_row~~CalledByGraph proc~valid_colum_or_row sudoku::valid_colum_or_row proc~valid_digit sudoku::valid_digit proc~valid_digit->proc~valid_colum_or_row proc~valid_grid sudoku::valid_grid proc~valid_grid->proc~valid_colum_or_row proc~cli_solver sudoku::cli_solver proc~cli_solver->proc~valid_grid proc~create_filled_grid sudoku::create_filled_grid proc~create_filled_grid->proc~valid_digit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, dimension(1:9) :: counters integer, public :: i","tags":"","loc":"proc/valid_colum_or_row.html"},{"title":"valid_digit – ForSudoku","text":"public pure function valid_digit(grid, row, col) Returns true if the row, column and region of a digit are all valid: Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(9, 9) :: grid Sudoky grid. integer, intent(in) :: row Row number of the region. integer, intent(in) :: col Column number of the region. Return Value logical Calls proc~~valid_digit~~CallsGraph proc~valid_digit sudoku::valid_digit proc~valid_colum_or_row sudoku::valid_colum_or_row proc~valid_digit->proc~valid_colum_or_row proc~valid_zone sudoku::valid_zone proc~valid_digit->proc~valid_zone Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~valid_digit~~CalledByGraph proc~valid_digit sudoku::valid_digit proc~create_filled_grid sudoku::create_filled_grid proc~create_filled_grid->proc~valid_digit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: j","tags":"","loc":"proc/valid_digit.html"},{"title":"valid_grid – ForSudoku","text":"public pure function valid_grid(grid) Check if the whole grid is valid. Returns true if a full grid is valid. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(9, 9) :: grid Sudoku grid. Return Value logical Calls proc~~valid_grid~~CallsGraph proc~valid_grid sudoku::valid_grid proc~valid_colum_or_row sudoku::valid_colum_or_row proc~valid_grid->proc~valid_colum_or_row proc~valid_zone sudoku::valid_zone proc~valid_grid->proc~valid_zone Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~valid_grid~~CalledByGraph proc~valid_grid sudoku::valid_grid proc~cli_solver sudoku::cli_solver proc~cli_solver->proc~valid_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: col integer, public :: row","tags":"","loc":"proc/valid_grid.html"},{"title":"valid_zone – ForSudoku","text":"public pure function valid_zone(region) Validation of a zone/region. Returns true if each digit in the 3x3 region appears only once. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(1:3, 1:3) :: region Sudoku’s subregion Return Value logical Called by proc~~valid_zone~~CalledByGraph proc~valid_zone sudoku::valid_zone proc~valid_digit sudoku::valid_digit proc~valid_digit->proc~valid_zone proc~valid_grid sudoku::valid_grid proc~valid_grid->proc~valid_zone proc~cli_solver sudoku::cli_solver proc~cli_solver->proc~valid_grid proc~create_filled_grid sudoku::create_filled_grid proc~create_filled_grid->proc~valid_digit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: col integer, public, dimension(1:9) :: counters integer, public :: row","tags":"","loc":"proc/valid_zone.html"},{"title":"cli_solver – ForSudoku","text":"public  subroutine cli_solver(grid, file) Provides a solution for a puzzle passed by CLI: $ ./executable test_in_02.txt Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(9, 9) :: grid Sudoku Grid character(len=*), intent(in) :: file Filepath Calls proc~~cli_solver~~CallsGraph proc~cli_solver sudoku::cli_solver proc~display_grid sudoku::display_grid proc~cli_solver->proc~display_grid proc~read_grid sudoku::read_grid proc~cli_solver->proc~read_grid proc~solve_puzzle sudoku::solve_puzzle proc~cli_solver->proc~solve_puzzle proc~valid_grid sudoku::valid_grid proc~cli_solver->proc~valid_grid proc~list_possible_digits sudoku::list_possible_digits proc~solve_puzzle->proc~list_possible_digits proc~sort sudoku::sort proc~solve_puzzle->proc~sort proc~valid_colum_or_row sudoku::valid_colum_or_row proc~valid_grid->proc~valid_colum_or_row proc~valid_zone sudoku::valid_zone proc~valid_grid->proc~valid_zone Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: presence","tags":"","loc":"proc/cli_solver.html"},{"title":"create_filled_grid – ForSudoku","text":"public  subroutine create_filled_grid(grid) Puzzle generators Grid generation by brute force: in each cycle a digit is added and\n checked for validity.  If the grid becomes invalid, the grid generation\n is started all over again. Arguments Type Intent Optional Attributes Name integer, intent(out), dimension(9, 9) :: grid Sudoku grid Calls proc~~create_filled_grid~~CallsGraph proc~create_filled_grid sudoku::create_filled_grid proc~valid_digit sudoku::valid_digit proc~create_filled_grid->proc~valid_digit proc~valid_colum_or_row sudoku::valid_colum_or_row proc~valid_digit->proc~valid_colum_or_row proc~valid_zone sudoku::valid_zone proc~valid_digit->proc~valid_zone Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: col real, public :: r integer, public :: row integer, public :: tests","tags":"","loc":"proc/create_filled_grid.html"},{"title":"create_puzzle – ForSudoku","text":"public  subroutine create_puzzle(grid, givens) Creates a puzzle by brute force.\nBut we are not 100% sure that the solution is unique\n(just a “high” probability). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(9, 9) :: grid Sudoku grid. integer, intent(in) :: givens Number of given digits in the puzzle. Calls proc~~create_puzzle~~CallsGraph proc~create_puzzle sudoku::create_puzzle proc~solve_puzzle sudoku::solve_puzzle proc~create_puzzle->proc~solve_puzzle proc~list_possible_digits sudoku::list_possible_digits proc~solve_puzzle->proc~list_possible_digits proc~sort sudoku::sort proc~solve_puzzle->proc~sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: col integer, public, dimension(9, 9) :: grid0 integer, public :: i integer, public, parameter :: n = 1000 real, public :: r (2) integer, public :: row integer, public, dimension(:, :, :), allocatable :: solutions logical, public :: unique","tags":"","loc":"proc/create_puzzle.html"},{"title":"create_puzzle_with_unique_solution – ForSudoku","text":"public  subroutine create_puzzle_with_unique_solution(grid, nb_empty) Creates a minimal puzzle.\nDigits are randomly removed one by one. The process ends when it is not\npossible anymore to remove a digit while keeping a unique solution.\nThe number of remaining digits is therefore a priori unknown. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(9, 9) :: grid integer, intent(out) :: nb_empty Calls proc~~create_puzzle_with_unique_solution~~CallsGraph proc~create_puzzle_with_unique_solution sudoku::create_puzzle_with_unique_solution proc~list_possible_digits sudoku::list_possible_digits proc~create_puzzle_with_unique_solution->proc~list_possible_digits Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: col integer, public :: d integer, public :: i integer, public, dimension(81) :: list integer, public :: n integer, public :: n1 integer, public :: n2 integer, public :: nb_possible real, public :: r (2) integer, public :: row integer, public :: temp","tags":"","loc":"proc/create_puzzle_with_unique_solution.html"},{"title":"display_grid – ForSudoku","text":"public  subroutine display_grid(grid) Display a grid on the terminal. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(9, 9) :: grid Called by proc~~display_grid~~CalledByGraph proc~display_grid sudoku::display_grid proc~cli_solver sudoku::cli_solver proc~cli_solver->proc~display_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: col integer, public :: row","tags":"","loc":"proc/display_grid.html"},{"title":"initialize_random_number_generator – ForSudoku","text":"public  subroutine initialize_random_number_generator(user_seed) System independent initialization of pseudo-random generator Initialize random number generator with a seed. Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: user_seed Variables Type Visibility Attributes Name Initial integer, public :: i integer, public :: n integer, public, allocatable, dimension(:) :: seed integer, public, dimension(1:8) :: time_values","tags":"","loc":"proc/initialize_random_number_generator.html"},{"title":"list_possible_digits – ForSudoku","text":"public pure subroutine list_possible_digits(grid, row, col, nb_possible, possible_digit) Procedure to create a list of allowed digits in the present empty cell. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(9, 9) :: grid Sudoku grid integer, intent(in) :: row Row number integer, intent(in) :: col Column number integer, intent(out) :: nb_possible integer, intent(out), optional, dimension(1:9) :: possible_digit Called by proc~~list_possible_digits~~CalledByGraph proc~list_possible_digits sudoku::list_possible_digits proc~create_puzzle_with_unique_solution sudoku::create_puzzle_with_unique_solution proc~create_puzzle_with_unique_solution->proc~list_possible_digits proc~solve_puzzle sudoku::solve_puzzle proc~solve_puzzle->proc~list_possible_digits proc~cli_solver sudoku::cli_solver proc~cli_solver->proc~solve_puzzle proc~create_puzzle sudoku::create_puzzle proc~create_puzzle->proc~solve_puzzle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: cr integer, public :: i integer, public :: j integer, public :: lr logical, public, dimension(0:9) :: possible","tags":"","loc":"proc/list_possible_digits.html"},{"title":"read_grid – ForSudoku","text":"public  subroutine read_grid(grid, filename) Read a grid from a provided the path to a file Arguments Type Intent Optional Attributes Name integer, intent(out), dimension(9, 9) :: grid Output grid character(len=*), intent(in) :: filename File path Called by proc~~read_grid~~CalledByGraph proc~read_grid sudoku::read_grid proc~cli_solver sudoku::cli_solver proc~cli_solver->proc~read_grid Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial logical, public :: file_exists integer, public :: fileunit character(len=2), public :: pipe1 character(len=2), public :: pipe2 integer, public :: row","tags":"","loc":"proc/read_grid.html"},{"title":"request_grid – ForSudoku","text":"public  subroutine request_grid(grid) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(9, 9) :: grid Variables Type Visibility Attributes Name Initial integer, public :: col integer, public :: row","tags":"","loc":"proc/request_grid.html"},{"title":"save_grid – ForSudoku","text":"public  subroutine save_grid(grid, filename) Input/Output routines Input/Output routines Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(9, 9) :: grid character(len=*), intent(in) :: filename Variables Type Visibility Attributes Name Initial integer, public :: col integer, public :: fileunit integer, public :: row","tags":"","loc":"proc/save_grid.html"},{"title":"solve_puzzle – ForSudoku","text":"public  subroutine solve_puzzle(grid) Receives a puzzle grid and solves it. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(9, 9) :: grid Input problem grid and returns solved grid. Calls proc~~solve_puzzle~~CallsGraph proc~solve_puzzle sudoku::solve_puzzle proc~list_possible_digits sudoku::list_possible_digits proc~solve_puzzle->proc~list_possible_digits proc~sort sudoku::sort proc~solve_puzzle->proc~sort Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~solve_puzzle~~CalledByGraph proc~solve_puzzle sudoku::solve_puzzle proc~cli_solver sudoku::cli_solver proc~cli_solver->proc~solve_puzzle proc~create_puzzle sudoku::create_puzzle proc~create_puzzle->proc~solve_puzzle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public :: col integer, public, dimension(1:81, 1:3) :: empty_cells integer, public, dimension(9, 9) :: grid0 integer, public :: i integer, public :: j integer, public :: nb_empty integer, public :: nb_possible integer, public, dimension(1:9) :: possible_digit real, public :: r integer, public :: row","tags":"","loc":"proc/solve_puzzle.html"},{"title":"sort – ForSudoku","text":"public pure subroutine sort(empty_cells, p, n) Solver routines Starting from position p, sort the list of empty cells by\n ascending number of allowed digits. We use a bubble sort algorithm Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(1:81, 1:3) :: empty_cells integer, intent(in) :: p The sort starts at position p (included) integer, intent(in) :: n Number of empty cells in the list Called by proc~~sort~~CalledByGraph proc~sort sudoku::sort proc~solve_puzzle sudoku::solve_puzzle proc~solve_puzzle->proc~sort proc~cli_solver sudoku::cli_solver proc~cli_solver->proc~solve_puzzle proc~create_puzzle sudoku::create_puzzle proc~create_puzzle->proc~solve_puzzle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Variables Type Visibility Attributes Name Initial integer, public, dimension(1:3) :: col integer, public :: i logical, public :: none_swap","tags":"","loc":"proc/sort.html"},{"title":"sudoku – ForSudoku","text":"Sudoku module @author: Vincent Magnin and Norwid Behrnd This module contains a set of procedures to generate sudokus grids and\nsolve them. Functions public pure function is_full (grid) Returns true if the grid is full. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(9, 9) :: grid Sudoky grid. Return Value logical public pure function valid_colum_or_row (vector) Validation routines Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(1:9) :: vector A row or a column Return Value logical public pure function valid_digit (grid, row, col) Returns true if the row, column and region of a digit are all valid: Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(9, 9) :: grid Sudoky grid. integer, intent(in) :: row Row number of the region. integer, intent(in) :: col Column number of the region. Return Value logical public pure function valid_grid (grid) Check if the whole grid is valid. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(9, 9) :: grid Sudoku grid. Return Value logical public pure function valid_zone (region) Validation of a zone/region. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(1:3, 1:3) :: region Sudoku’s subregion Return Value logical Subroutines public  subroutine cli_solver (grid, file) Provides a solution for a puzzle passed by CLI: Read more… Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(9, 9) :: grid Sudoku Grid character(len=*), intent(in) :: file Filepath public  subroutine create_filled_grid (grid) Puzzle generators Read more… Arguments Type Intent Optional Attributes Name integer, intent(out), dimension(9, 9) :: grid Sudoku grid public  subroutine create_puzzle (grid, givens) Creates a puzzle by brute force.\nBut we are not 100% sure that the solution is unique\n(just a “high” probability). Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(9, 9) :: grid Sudoku grid. integer, intent(in) :: givens Number of given digits in the puzzle. public  subroutine create_puzzle_with_unique_solution (grid, nb_empty) Creates a minimal puzzle.\nDigits are randomly removed one by one. The process ends when it is not\npossible anymore to remove a digit while keeping a unique solution.\nThe number of remaining digits is therefore a priori unknown. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(9, 9) :: grid integer, intent(out) :: nb_empty public  subroutine display_grid (grid) Display a grid on the terminal. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(9, 9) :: grid public  subroutine initialize_random_number_generator (user_seed) System independent initialization of pseudo-random generator Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), optional :: user_seed public pure subroutine list_possible_digits (grid, row, col, nb_possible, possible_digit) Procedure to create a list of allowed digits in the present empty cell. Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(9, 9) :: grid Sudoku grid integer, intent(in) :: row Row number integer, intent(in) :: col Column number integer, intent(out) :: nb_possible integer, intent(out), optional, dimension(1:9) :: possible_digit public  subroutine read_grid (grid, filename) Read a grid from a provided the path to a file Arguments Type Intent Optional Attributes Name integer, intent(out), dimension(9, 9) :: grid Output grid character(len=*), intent(in) :: filename File path public  subroutine request_grid (grid) Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(9, 9) :: grid public  subroutine save_grid (grid, filename) Input/Output routines Read more… Arguments Type Intent Optional Attributes Name integer, intent(in), dimension(9, 9) :: grid character(len=*), intent(in) :: filename public  subroutine solve_puzzle (grid) Receives a puzzle grid and solves it. Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(9, 9) :: grid Input problem grid and returns solved grid. public pure subroutine sort (empty_cells, p, n) Solver routines Read more… Arguments Type Intent Optional Attributes Name integer, intent(inout), dimension(1:81, 1:3) :: empty_cells integer, intent(in) :: p The sort starts at position p (included) integer, intent(in) :: n Number of empty cells in the list","tags":"","loc":"module/sudoku.html"},{"title":"sudoku.f90 – ForSudoku","text":"This file is part of the ForSudoku Fortran project.\n Copyright (C) 2006-2024 Vincent Magnin & Norwid Behrnd This is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 3, or (at your option)\n any later version. This software is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details. You should have received a copy of the GNU General Public License along with\n this program; see the files LICENSE and LICENSE_EXCEPTION respectively.\n If not, see http://www.gnu.org/licenses/ . Contributed by Vincent Magnin, 2006-11-27; Norwid Behrnd, 2023\n Last modifications: 2023-09-12, vmagnin 2024-03-23 Source Code !! This file is part of the ForSudoku Fortran project. !! Copyright (C) 2006-2024 Vincent Magnin & Norwid Behrnd !! !! This is free software; you can redistribute it and/or modify !! it under the terms of the GNU General Public License as published by !! the Free Software Foundation; either version 3, or (at your option) !! any later version. !! !! This software is distributed in the hope that it will be useful, !! but WITHOUT ANY WARRANTY; without even the implied warranty of !! MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the !! GNU General Public License for more details. !! !! You should have received a copy of the GNU General Public License along with !! this program; see the files LICENSE and LICENSE_EXCEPTION respectively. !! If not, see <http://www.gnu.org/licenses/>. !!------------------------------------------------------------------------------ !! Contributed by Vincent Magnin, 2006-11-27; Norwid Behrnd, 2023 !! Last modifications: 2023-09-12, vmagnin 2024-03-23 !!------------------------------------------------------------------------------ module sudoku !! Sudoku module !! !! @author: Vincent Magnin and Norwid Behrnd !! !! This module contains a set of procedures to generate sudokus grids and !! solve them. implicit none contains !***************************************************************************** ! Input/Output routines !***************************************************************************** subroutine save_grid ( grid , filename ) !! Input/Output routines integer , dimension ( 9 , 9 ), intent ( in ) :: grid character ( * ), intent ( in ) :: filename integer :: row , col integer :: fileunit ! file creation: open ( newunit = fileunit , file = filename , status = \"REPLACE\" ) do row = 1 , 9 write ( fileunit , '(3I2, \" |\", 3I2, \" |\", 3I2)' ) ( grid ( row , col ), col = 1 , 9 ) if (( row == 3 ) . or . ( row == 6 )) then write ( fileunit , * ) \"------+-------+------\" end if end do close ( fileunit ) end subroutine save_grid subroutine read_grid ( grid , filename ) !! Read a grid from a provided the path to a file integer , dimension ( 9 , 9 ), intent ( out ) :: grid !! Output grid character ( * ), intent ( in ) :: filename !! File path character ( len = 2 ) :: pipe1 , pipe2 ! to read the pipe/the vertical bar integer :: row integer :: fileunit logical :: file_exists ! check for the presence of the file requested inquire ( file = filename , exist = file_exists ) if ( file_exists . eqv . . false .) stop \"The requested file is absent.\" ! open and read the file, line by line open ( newunit = fileunit , file = filename ) do row = 1 , 9 read ( fileunit , '(3I2, A2, 3I2, A2, 3I2)' ) & grid ( row , 1 : 3 ), pipe1 , grid ( row , 4 : 6 ), pipe2 , grid ( row , 7 : 9 ) ! skip the lines of dashes if (( row == 3 ) . or . ( row == 6 )) then read ( fileunit , * ) end if end do close ( fileunit ) end subroutine read_grid subroutine display_grid ( grid ) !! Display a grid on the terminal. integer , dimension ( 9 , 9 ), intent ( in ) :: grid integer :: row , col do row = 1 , 9 print '(3I2, \" |\", 3I2, \" |\", 3I2)' , ( grid ( row , col ), col = 1 , 9 ) if (( row == 3 ) . or . ( row == 6 )) then print * , \"------+-------+------\" end if end do end subroutine display_grid subroutine request_grid ( grid ) integer , dimension ( 9 , 9 ), intent ( inout ) :: grid integer :: row , col do row = 1 , 9 write ( * , \"(A, I1, A)\" ) \"Enter line \" , row , \":\" read * , ( grid ( row , col ), col = 1 , 9 ) end do end subroutine request_grid !***************************************************************************** ! Validation routines !***************************************************************************** pure logical function valid_colum_or_row ( vector ) !! Validation of either a row or a column. !! !! Returns true if each digit in the 1D array appears only once integer , dimension ( 1 : 9 ), intent ( in ) :: vector !! A row or a column ! The number of occurrences of each digit: integer , dimension ( 1 : 9 ) :: counters integer :: i counters = 0 do i = 1 , 9 associate ( d => vector ( i )) if ( d /= 0 ) then counters ( d ) = counters ( d ) + 1 if ( counters ( d ) > 1 ) then valid_colum_or_row = . false . return ! We leave immediately the function and return false end if end if end associate end do valid_colum_or_row = . true . end function valid_colum_or_row pure logical function valid_zone ( region ) !! Validation of a zone/region. !! !! Returns true if each digit in the 3x3 region appears only once. integer , dimension ( 1 : 3 , 1 : 3 ), intent ( in ) :: region !! Sudoku's subregion ! The number of occurrences of each digit: integer , dimension ( 1 : 9 ) :: counters integer :: row , col counters = 0 do row = 1 , 3 do col = 1 , 3 associate ( d => region ( row , col )) if ( d /= 0 ) then counters ( d ) = counters ( d ) + 1 if ( counters ( d ) > 1 ) then valid_zone = . false . return ! We leave immediately the function and return false end if end if end associate end do end do valid_zone = . true . end function valid_zone pure logical function valid_grid ( grid ) !! Check if the whole grid is valid. !! !! Returns true if a full grid is valid. integer , dimension ( 9 , 9 ), intent ( in ) :: grid !! Sudoku grid. integer :: row , col ! Verification of the 9 lines: do row = 1 , 9 if (. not . valid_colum_or_row ( grid ( row , 1 : 9 ))) then valid_grid = . false . return end if end do ! Verification of the 9 columns: do col = 1 , 9 if (. not . valid_colum_or_row ( grid ( 1 : 9 , col ))) then valid_grid = . false . return end if end do ! Verification of the 9 regions: do row = 1 , 7 , + 3 do col = 1 , 7 , + 3 if (. not . valid_zone ( grid ( row : row + 2 , col : col + 2 ))) then valid_grid = . false . return end if end do end do valid_grid = . true . end function valid_grid pure logical function valid_digit ( grid , row , col ) !! Returns true if the row, column and region of a digit are all valid: integer , dimension ( 9 , 9 ), intent ( in ) :: grid !! Sudoky grid. integer , intent ( in ) :: row !! Row number of the region. integer , intent ( in ) :: col !! Column number of the region. integer :: i , j i = ( row - 1 ) / 3 j = ( col - 1 ) / 3 valid_digit = valid_colum_or_row ( grid ( row , 1 : 9 )) . and . & valid_colum_or_row ( grid ( 1 : 9 , col )) . and . & valid_zone ( grid ( i * 3 + 1 : i * 3 + 3 , j * 3 + 1 : j * 3 + 3 )) end function valid_digit pure logical function is_full ( grid ) !! Returns true if the grid is full. integer , dimension ( 9 , 9 ), intent ( in ) :: grid !! Sudoky grid. if ( any ( grid (:,:) == 0 )) then is_full = . false . else is_full = . true . end if end function pure subroutine list_possible_digits ( grid , row , col , & nb_possible , possible_digit ) !! Procedure to create a list of allowed digits in the present empty cell. integer , dimension ( 9 , 9 ), intent ( in ) :: grid !! Sudoku grid integer , intent ( in ) :: row !! Row number integer , intent ( in ) :: col !! Column number ! These arguments are returned: integer , intent ( out ) :: nb_possible integer , dimension ( 1 : 9 ), optional , intent ( out ) :: possible_digit integer :: cr , lr , i , j logical , dimension ( 0 : 9 ) :: possible ! Each digit is either possible or not possible = . true . ! Given digits in those row and column are excluded: do j = 1 , 9 possible ( grid ( j , col )) = . false . possible ( grid ( row , j )) = . false . end do ! Given digits in that region are excluded: lr = 1 + 3 * (( row - 1 ) / 3 ) cr = 1 + 3 * (( col - 1 ) / 3 ) do i = lr , lr + 2 do j = cr , cr + 2 possible ( grid ( i , j )) = . false . end do end do nb_possible = 0 if ( present ( possible_digit )) possible_digit = 0 ! Count and store the remaining possible digits: do j = 1 , 9 if ( possible ( j )) then nb_possible = nb_possible + 1 if ( present ( possible_digit )) possible_digit ( nb_possible ) = j end if end do end subroutine list_possible_digits !***************************************************************************** ! Solver routines !***************************************************************************** pure subroutine sort ( empty_cells , p , n ) !! Starting from position p, sort the list of empty cells by !! ascending number of allowed digits. We use a bubble sort algorithm integer , dimension ( 1 : 81 , 1 : 3 ), intent ( inout ) :: empty_cells !! integer , intent ( in ) :: p !! The sort starts at position p (included) integer , intent ( in ) :: n !! Number of empty cells in the list integer :: i integer , dimension ( 1 : 3 ) :: col logical :: none_swap do ! Compare each cell with the next one and swap them if necessary: none_swap = . true . do i = p , n - 1 if ( empty_cells ( i , 3 ) > empty_cells ( i + 1 , 3 )) then ! Swap them: col = empty_cells ( i , :) empty_cells ( i , :) = empty_cells ( i + 1 , :) empty_cells ( i + 1 , :) = col none_swap = . false . end if end do if ( none_swap ) exit ! The bubble sort is finished end do end subroutine sort subroutine solve_puzzle ( grid ) !! Receives a puzzle grid and solves it. integer , dimension ( 9 , 9 ), intent ( inout ) :: grid !! Input problem grid and returns solved grid. integer , dimension ( 9 , 9 ) :: grid0 real :: r ! Random number integer :: row , col , i , j ! Counter of empty cells: integer :: nb_empty ! List of empty cells: integer , dimension ( 1 : 81 , 1 : 3 ) :: empty_cells ! List and number of possible digits: integer , dimension ( 1 : 9 ) :: possible_digit integer :: nb_possible ! Save the initial grid: grid0 = grid ! Identify and store the coordinates of empty cells in the grid ! in the table \"empty_cells\": empty_cells = 0 nb_empty = 0 do row = 1 , 9 do col = 1 , 9 if ( grid ( row , col ) == 0 ) then nb_empty = nb_empty + 1 empty_cells ( nb_empty , 1 ) = row empty_cells ( nb_empty , 2 ) = col end if end do end do ! Iterate over all empty cells: possible_digit = 0 i = 1 do while ( i <= nb_empty ) ! To accelerate the algorithm, count for each empty cell the digits ! which could be inserted in that cell: do j = i , nb_empty row = empty_cells ( j , 1 ) col = empty_cells ( j , 2 ) ! The last two arguments have intent(out): call list_possible_digits ( grid , row , col , empty_cells ( j , 3 )) ! empty_cells(j, 3) will contain the nb of possible digits for the ! empty cell number j. end do ! Sort the empty cells: call sort ( empty_cells , i , nb_empty ) ! For the empty cell i, regenerate a list of possible digits: row = empty_cells ( i , 1 ) col = empty_cells ( i , 2 ) call list_possible_digits ( grid , row , col , & & nb_possible , possible_digit ) ! If there are possibilities, choose randomly one and ! continue with the next empty cell: if ( nb_possible > 0 ) then call random_number ( r ) ! 0 <= r < 1 grid ( row , col ) = possible_digit ( 1 + int ( r * nb_possible )) i = i + 1 else ! Start all over again i = 1 grid = grid0 end if end do end subroutine solve_puzzle subroutine cli_solver ( grid , file ) !! Provides a solution for a puzzle passed by CLI: !! !! ```shell !! $ ./executable test_in_02.txt !! ``` integer , dimension ( 9 , 9 ), intent ( inout ) :: grid !! Sudoku Grid character ( * ), intent ( in ) :: file !! Filepath logical :: presence presence = . false . inquire ( file = file , exist = presence ) if ( presence . eqv . . false .) then print * , \"ERROR: the requested file '\" , file , \"' is inaccessible.\" else call read_grid ( grid , file ) if ( valid_grid ( grid ) . eqv . . true .) then call solve_puzzle ( grid ) call display_grid ( grid ) else print * , \"The input file'\" , file , \"' is an invalid grid.\" end if end if end subroutine cli_solver !***************************************************************************** ! Puzzle generators !***************************************************************************** subroutine create_filled_grid ( grid ) !! Grid generation by brute force: in each cycle a digit is added and !! checked for validity.  If the grid becomes invalid, the grid generation !! is started all over again. integer , dimension ( 9 , 9 ), intent ( out ) :: grid !! Sudoku grid real :: r integer :: row , col integer :: tests restart : do ! We start with an empty grid: grid = 0 try : do row = 1 , 9 do col = 1 , 9 tests = 0 digit : do tests = tests + 1 ! We add a random digit in the grid: call random_number ( r ) grid ( row , col ) = 1 + int ( r * 9 ) ! and check if the Sudoku constraints are OK: if ( valid_digit ( grid , row , col )) then ! Let's continue with other cells: exit digit else if ( tests > 30 ) then ! The probability of finding a valid digit is low, ! and we therefore restart a new grid: cycle restart end if end if end do digit end do end do try ! We have left naturally the \"try\" loop ! and have therefore found a valid grid: exit end do restart end subroutine create_filled_grid subroutine create_puzzle_with_unique_solution ( grid , nb_empty ) !! Creates a minimal puzzle. !! Digits are randomly removed one by one. The process ends when it is not !! possible anymore to remove a digit while keeping a unique solution. !! The number of remaining digits is therefore a priori unknown. integer , dimension ( 9 , 9 ), intent ( inout ) :: grid integer , intent ( out ) :: nb_empty ! List of the cells, numbered from 1 to 81, line by line: integer , dimension ( 81 ) :: list real :: r ( 2 ) ! To draw two random numbers integer :: row , col , n , n1 , n2 , i , temp , d integer :: nb_possible ! List of the cells, numbered from 1 to 81, line by line: list = [( i , i = 1 , 81 )] ! The list is randomly shuffled to avoid removing too many neighbours. ! The probability that a position is never drawn is (80/81)&#94;81 ~ 0.107 ! Increasing the upper limit would impede performance. do i = 1 , 81 ! We draw two positions: call random_number ( r ) ! 0 <= r < 1 n1 = 1 + int ( r ( 1 ) * 81 ) n2 = 1 + int ( r ( 2 ) * 81 ) ! and swap them in the list: temp = list ( n1 ) list ( n1 ) = list ( n2 ) list ( n2 ) = temp end do nb_empty = 0 ! Remove digits one by one: do i = 1 , 81 ! Number of the cell in the shuffled list: n = list ( i ) ! Coordinates of the cell in the grid: row = 1 + ( n - 1 ) / 9 col = 1 + mod ( n - 1 , 9 ) ! We save then delete the digit in that cell: d = grid ( row , col ) grid ( row , col ) = 0 ! How many digits are possible at that position? ! Note: 79% of CPU time is spent in list_possible_digits() call list_possible_digits ( grid , row , col , nb_possible ) if ( nb_possible > 1 ) then ! We put back the digit in the cell: grid ( row , col ) = d ! and we continue with the next cell in the list... else nb_empty = nb_empty + 1 end if end do end subroutine create_puzzle_with_unique_solution subroutine create_puzzle ( grid , givens ) !! Creates a puzzle by brute force. !! But we are not 100% sure that the solution is unique !! (just a \"high\" probability). integer , dimension ( 9 , 9 ), intent ( inout ) :: grid !! Sudoku grid. integer , intent ( in ) :: givens !! Number of given digits in the puzzle. integer , dimension ( 9 , 9 ) :: grid0 ! Maximum number of times we try to solve a grid: integer , parameter :: n = 1000 ! To store and compare the n Sudoku solutions: integer , dimension (:, :, :), allocatable :: solutions real :: r ( 2 ) integer :: row , col , i logical :: unique allocate ( solutions ( 1 : n , 1 : 9 , 1 : 9 )) ! Save the initial grid: grid0 = grid print * , \"Search of a puzzle (without guaranty for a unique solution)...\" do grid = grid0 ! Show the advancement of the algorithm: write ( * , '(\".\")' , advance = 'no' ) ! Remove digits: do i = 1 , 81 - givens ! Choose randomly a cell with a digit: do call random_number ( r ) row = 1 + int ( r ( 1 ) * 9 ) col = 1 + int ( r ( 2 ) * 9 ) if ( grid ( row , col ) /= 0 ) exit end do ! Erase the digit in this cell: grid ( row , col ) = 0 end do ! The grid is solved up to n times to increase the probability that ! the solution is unique: unique = . true . solve : do i = 1 , n solutions ( i , :, :) = grid call solve_puzzle ( solutions ( i , :, :)) ! Is that solution identical to all previous ones? if ( i >= 2 ) then if ( any ( solutions ( i , :, :) /= solutions ( i - 1 , :, :))) then unique = . false . exit solve end if end if end do solve if ( unique ) exit end do write ( * , * ) end subroutine create_puzzle !************************************************************** ! System independent initialization of pseudo-random generator !************************************************************** subroutine initialize_random_number_generator ( user_seed ) !! Initialize random number generator with a seed. integer , optional , intent ( in ) :: user_seed integer , allocatable , dimension (:) :: seed integer , dimension ( 1 : 8 ) :: time_values integer :: i , n call random_seed ( size = n ) allocate ( seed ( 1 : n )) if ( present ( user_seed )) then seed = user_seed else ! Real-time clock: call date_and_time ( values = time_values ) ! We use the milliseconds to compute the seeds: do i = 1 , n seed ( i ) = ( huge ( seed ( i )) / 1000 ) * time_values ( 8 ) - i end do end if call random_seed ( put = seed ( 1 : n )) end subroutine initialize_random_number_generator end module sudoku","tags":"","loc":"sourcefile/sudoku.f90.html"}]}